#include <bits/stdc++.h>
using namespace std;
 
#define int long long
#define all(v) v.begin(), v.end()
#define F(a,b,i) for (int i = a; i < b; i++)
#define Rev(a,b,i) for (int i = a; i >= b; i--)
#define RISHI ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);
 
template <typename dStruct>
void print(dStruct& vName){for(auto &it : vName){cout<<it<<" ";} cout<<"\n";}
template <typename dStruct>
void print2(dStruct& vName){for(auto &it : vName){cout<<"{"<<it.first<<", "<<it.second<<"} ";} cout<<"\n";}
 
const int mod = 1e9 + 7;
#define inf LONG_LONG_MAX
#define Min LONG_LONG_MIN
 
typedef long double ld;
typedef vector<int> vi;
 
/*---------------------------------------->   MAGIC STARTS   <--------------------------------------------*/

/*
A rotation of a string can be generated by moving characters one after another from
beginning to end. For example, the rotations of acab are acab, caba, abac, and baca.
Your task is to determine the lexicographically minimal rotation of a string.

Minimal Rotation :- Booth's Algorithm
Blog :- https://codeforces.com/blog/entry/79979
*/
 
int32_t main()
{
    RISHI
    int T = 1;
    while(T--)
    {
        string s; cin>>s;
        s += s;
        int n = s.size();
 
        vi dp(n,-1);
        int k = 0;
 
        for(int i=1; i<n; i++){
            char c = s[i];
            int f = dp[i-k-1];
 
            while(f!=-1 && c!=s[k+f+1]){
                if(c<s[k+f+1]){
                    k = i-f-1;
                }
                f = dp[f];
            }
 
            if(c!=s[k+f+1]){
                if(c<s[k]){
                    k = i;
                }
                dp[i-k] = -1;
            }
            else{
                dp[i-k] = f+1;
            }
        }
 
        for(int i=0; i<(n/2); i++){
            cout<<s[i+k];
        }
        
    }
 
}
 
 
